## 事务是否隔离了？
行锁中，一个事务要更新一行，如果刚好有另外一个事务拥有这一行的行锁，就会被锁住，进入等待状态。既然进入等待状态，那么等到这个事务自己获取到行锁更新数据的时候，读到的值又是什么？
MySQL是有视图的概念，一个是view，创建视图的语法时create view... 一个是Innodb在实现MVCC时用到的一致性读视图，也就是consistent read view用于支持RC和RR<br>
Innodb里面每个事务有一个唯一的事务ID。每次事务更新数据的时候，都会生成一个新的数据版本，并且把transaction id赋值给这个数据版本的事务ID，记为row trx_id。也就是说，一行记录，可能有多个版本！<br>
* 版本未提交，不可见
* 版本已提交，但是在视图创建之后提交的，不可见
* 版本已提交，在视图创建之前提交的，可见

**更新数据都是先读后写的，而这个读，只能读当前的值，称之为当前读**<br>
可重复读的核心就是一致性读(consistent)；而事务更新数据的时候，只能用当前读，如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待<br>
* 可重复读，查询只承认在事务启动前已经提交完成的数据
* 读提交 查询只承认在语句启动前就已经提交完成的数据
* 当前读 总是读取已经提交完成的最新版本


